}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(3)
m
tmp=function(x=numeric())
m=NULL
m
set <- function(y) {
x <<- y
m <<- NULL
}
set
set(x)
set5
set(4)
set
y
x
x
y
m
set()
get=function()x
get
get(5)
get()4
?function
?function()
?function
?NULL
setmean=function(mean)m=mean
setmean=function(mean)m<<-mean
setmean
function(mean)
m=mean
function(4)
function(2,4,5)
list(set=set,get=get,setmean=setmean,getmean=getmean)
list
getmean=function()m
list(set=set,get=get,setmean=setmean,getmean=getmean)
makeVector(2,5,7)
makeVector(2)
v=makeVector(c(1,2,3))
v
class(v)
str(v)
summary(v)
cachemean(4)
summary(cachemean)
cachemean(v)
v
Guess <- function(max) {
secret.number <- sample(1:max, 1)
total.guesses <- 1
finished <- FALSE
message(sprintf("I'm thinking of a number from 1 to %d.", max))
self.list <- list(
get.info = function() {
message(
sprintf(
"You %s guessed the number!",
if (finished) "have already"
else "still haven't"
)
)
message(sprintf("Guess number: %d", total.guesses))
message(sprintf("The number is taken from 1 to %d.", max))
},
get.clues = function(guess) {
if (finished) message("You've already guessed my number!")
else {
if (guess == secret.number) {
message("Congratulations!")
message(sprintf("You got it in %d guesses!", total.guesses))
finished <<- TRUE
} else {
if (secret.number < guess) message("Too high!")
else message("Too low!")
total.guesses <<- total.guesses + 1
}
}
}
)
class(self.list) <- "Guess"
self.list
}
game=Guess(100)
class(game)
game$get.info()
game$get.clues(50)
x
x$getmean
x$getmean()
summary(x)
cachemean(4)
makeVector(c(2,5,7,14))
mean(c(2,5,7,14))
v=makeVector(c(2,5,7,14))
mean(v)
cacheman(v)
cachemean(v)
cachemean(v)
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setmatrix <- function(solve) s <<- solve
invertmatrix <- function() s
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cacheSolve <- function(x, ...) {
m <- x$invertmatrix()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(s)
m
}
?matrix
mat=matrix(c,1,2,3, 4,5,6)
mat=matrix(c,1,2 4,5)
mat=matrix(c(1,2  4,5),nrow=2, ncol=2)
mat=matrix(c(1,2,  4,5),nrow=2, ncol=2)
mat
makeCacheMatrix(mat)
makeCacheMatrix(mat)
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setmatrix <- function(solve) s <<- solve
invertmatrix <- function() s
list(set = set, get = get,
setmatrix = setmatrix,
invertmatrix = invertmatrix)
}
makeCacheMatrix(mat)
cacheSolve(mat)
cacheSolve <- function(x, ...) {
s <- x$invertmatrix()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setmatrix(s)
s
}
cacheSolve(mat)
cacheSolve(mat)
x
set
makeCacheMatrix(mat)
summary(mat)
summary(makeCacheMatrix)
solve(mat)
?solve
mat
solve(mat)
mat=rbind(c(4,3, 3,2))
mat
mat=rbind(c(4,3, 3,2), nrow=2)
mat
mat=rbind(c(4,3, 3,2), nrow=2,ncol=2)
mat
mat=matrix(c(4,3, 3,2))
mat
mat=matrix(c(4,3, 3,2), nrow=2, ncol=2)
mat
makeCacheMatrix(mat)
cacheSolve(mat)
solve(mat)
s
mat=makeCacheMatrix(matrix(c(4,3,3,2),nrow=2,ncol=2))
mat$get()
cacheSolve(mat)
cacheSolve(mat)
mat$getinverse()
cacheSolve(makeCacheMatrix,mat)
mat$getinverse()
mat
mat$$get()
mat$get()
cacheSolve(mat)
mat$getinverse()
cacheSolve(mat)
mat$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
cacheSolve(mat)
mat$get()
mat$getinverse()
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setmatrix <- function(inverse) s <<- inverse
getinverse <- function() s
list(set = set, get = get,
setmatrix = setmatrix,
getinverse = getinverse)
}
mat
mat=makeCacheMatrix(matrix(c(4,3,3,2),nrow=2,ncol=2))
mat$$get()
mat$get()
cacheSolve(mat)
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setmatrix <- function(inverse) s <<- inverse
getinverse <- function() s
list(set = set, get = get,
setmatrix = setmatrix,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
s <- x$getinverse()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setmatrix(s)
s
}
mat=makeCacheMatrix(matrix(c(4,3,3,2),nrow=2,ncol=2))
mat$get()
cacheSolve(mat)
mat$getinverse()
cacheSolve(mat)
mat$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
cacheSolve(mat)
mat$get()
mat$getinverse()
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
s
class(s)
class(s)
class(x)
class(set)
get <- function() x
class(get)
set(5)
set
mat=(matrix(c:1:4,nrow=2,ncol=2))
mat=(matrix(c(1:4,nrow=2,ncol=2))
)
makeCacheMatrix(mat)
## Script includes two functions: makeCacheMatrix and cacheSolve.
## Together, these functions will calculate the inverse of a given matrix,
## or allow results (inverted matrices) from previously calcuated instances
## of the given matrix to be called.
## makeCacheMatrix: this function returns a list of functions that defines
## the location of where a given matrix will be cached.
## Function named as makeCacheMatrix with input "x", (where x is a square matrix).
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
## set function allows the matrix to be modified.
set <- function(y) {
x <<- y
s <<- NULL
}
## get function will return the matrix given in the parent function.
get <- function() x
## setmatrix function modifies the a matrix
setmatrix <- function(matrix) s <<- matrix
## get function returns the inverse of a given matrix
getmatrix <- function() s
## list command aggregates the previously defined four functions into a list
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## cacheSolve: this function calcuates the inverse of a matrix after searching
## if previous instances of the matrix have been calculated.
# function named as cacheSolve with input "x", (where x is a square matrix).
cacheSolve <- function(x, ...) {
## variable "s" defined as matrix with inverse.
s <- x$getmatrix()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setmatrix(s)
s
}
makeCacheMatrix(mat)
mat$get
## Script includes two functions: makeCacheMatrix and cacheSolve.
## Together, these functions will calculate the inverse of a given matrix,
## or allow results (inverted matrices) from previously calcuated instances
## of the given matrix to be called.
## makeCacheMatrix: this function returns a list of functions that defines
## the location of where a given matrix will be cached.
## Function named as makeCacheMatrix with input "x", (where x is a square matrix).
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
## set function allows the matrix to be modified.
set <- function(y) {
x <<- y
s <<- NULL
}
## get function will return the matrix given in the parent function.
get <- function() x
## setmatrix function modifies the a matrix
setmatrix <- function(matrix) s <<- matrix
## get function returns the inverse of a given matrix
getmatrix <- function() s
## list command aggregates the previously defined four functions into a list
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## cacheSolve: this function calcuates the inverse of a matrix after searching
## if previous instances of the matrix have been calculated.
# function named as cacheSolve with input "x", (where x is a square matrix).
cacheSolve <- function(x, ...) {
## variable "s" defined as matrix with inverse.
s <- x$getmatrix()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setmatrix(s)
s
}
mat=(matrix(c(1:4,nrow=2,ncol=2)))
mat$get
mat$get
mat
mat=(matrix(c(1:4),nrow=2,ncol=2))
mat$get
mat
makeCacheMatrix(mat)
mat$get
mat
mat$get
mat$get
mat$get
mat$get
mat$set
## Script includes two functions: makeCacheMatrix and cacheSolve.
## Together, these functions will calculate the inverse of a given matrix,
## or allow results (inverted matrices) from previously calcuated instances
## of the given matrix to be called.
## makeCacheMatrix: this function returns a list of functions that defines
## the location of where a given matrix will be cached.
## Function named as makeCacheMatrix with input "x", (where x is a square matrix).
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
## set function allows the matrix to be modified.
set <- function(y) {
x <<- y
s <<- NULL
}
## get function will return the matrix given in the parent function.
get <- function() x
## setmatrix function modifies the a matrix
setmatrix <- function(matrix) s <<- matrix
## get function returns the inverse of a given matrix
getmatrix <- function() s
## list command aggregates the previously defined four functions into a list
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## cacheSolve: this function calcuates the inverse of a matrix after searching
## if previous instances of the matrix have been calculated.
# function named as cacheSolve with input "x", (where x is a square matrix).
cacheSolve <- function(x, ...) {
## variable "s" defined as matrix with inverse.
s <- x$getmatrix()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setmatrix(s)
s
}
mat
mat=matrix(c(1:4), nrow=2, ncol=2)
mat
makeCacheMatrix(mat)
mat$get
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setmatrix <- function(inverse) s <<- inverse
getinverse <- function() s
list(set = set, get = get,
setmatrix = setmatrix,
getinverse = getinverse)
}
makeCacheMatrix(mat)
mat$get
mat$get()
mat$get()
setwd('/Users/dshong/')
setwd('/Users/dshong/Documents/git/ExploratoryAnalysis/CourseProject1/')
ls
##Download zipfile, unzip and read table into dataframe
source_url <- ("https://d396qusza40orc.cloudfront.net/exdata%2Fdata%2Fhousehold_power_consumption.zip")
zipdata <- tempfile()
download.file(source_url, zipdata, method = "curl")
data <- read.table(unz(zipdata, "household_power_consumption.txt"), sep = ";", header = T, colClasses = c("character", "character", rep("numeric", 7)), na.strings = "?")
##Subset data to include range from 2/1/2007-2/2/2007 and convert date into POSIXlt date/time format
data01 = subset(data, data$Date == "1/2/2007")
data02 = subset(data, data$Date == "2/2/2007")
dataFinal = rbind(data01,data02)
dataFinal$Date <- strptime(paste(dataFinal$Date, dataFinal$Time), "%d/%m/%Y %H:%M:%S")
##Plot histogram and save to png format
png('plot1.png',bg = "transparent", width = 480, height = 480, units = "px")
hist(dataFinal$Global_active_power, col="red", main='Global Active Power', xlab = 'Global Active Power (kilowatts)')
dev.off()
##Download zipfile, unzip and read table into dataframe
source_url <- ("https://d396qusza40orc.cloudfront.net/exdata%2Fdata%2Fhousehold_power_consumption.zip")
zipdata <- tempfile()
download.file(source_url, zipdata, method = "curl")
data <- read.table(unz(zipdata, "household_power_consumption.txt"), sep = ";", header = T, colClasses = c("character", "character", rep("numeric", 7)), na.strings = "?")
##Subset data to include range from 2/1/2007-2/2/2007 and convert date into POSIXlt date/time format
data01 = subset(data, data$Date == "1/2/2007")
data02 = subset(data, data$Date == "2/2/2007")
dataFinal = rbind(data01,data02)
dataFinal$Date <- strptime(paste(dataFinal$Date, dataFinal$Time), "%d/%m/%Y %H:%M:%S")
##Plot line graph and save to png format
png('plot2.png',bg = "transparent", width = 480, height = 480, units = "px")
plot(dataFinal$Global_active_power ~ as.POSIXct(dataFinal$Date), type = "l",ylab = "Global Active Power (kilowatts)", xlab = "")
dev.off()
source_url <- ("https://d396qusza40orc.cloudfront.net/exdata%2Fdata%2Fhousehold_power_consumption.zip")
zipdata <- tempfile()
download.file(source_url, zipdata, method = "curl")
data <- read.table(unz(zipdata, "household_power_consumption.txt"), sep = ";", header = T, colClasses = c("character", "character", rep("numeric", 7)), na.strings = "?")
##Subset data to include range from 2/1/2007-2/2/2007 and convert date into POSIXlt date/time format
data01 = subset(data, data$Date == "1/2/2007")
data02 = subset(data, data$Date == "2/2/2007")
dataFinal = rbind(data01,data02)
dataFinal$Date <- strptime(paste(dataFinal$Date, dataFinal$Time), "%d/%m/%Y %H:%M:%S")
##Plot multiple line graphs with legend and save to png format
png('plot3.png',bg = "transparent", width = 480, height = 480, units = "px")
plot(dataFinal$Sub_metering_1 ~ as.POSIXct(dataFinal$Date), type = "l", ylab = "Energy sub metering", xlab = "")
lines(dataFinal$Sub_metering_2 ~ as.POSIXct(dataFinal$Date), col = "red")
lines(dataFinal$Sub_metering_3 ~ as.POSIXct(dataFinal$Date), col = "blue")
legend("topright", c("Sub_metering_1", "Sub_metering_2", "Sub_metering_3"), col = c("black", "red", "blue"), lty=c(1,1), lwd=c(1,1))
dev.off()
source_url <- ("https://d396qusza40orc.cloudfront.net/exdata%2Fdata%2Fhousehold_power_consumption.zip")
zipdata <- tempfile()
download.file(source_url, zipdata, method = "curl")
data <- read.table(unz(zipdata, "household_power_consumption.txt"), sep = ";", header = T, colClasses = c("character", "character", rep("numeric", 7)), na.strings = "?")
##Subset data to include range from 2/1/2007-2/2/2007 and convert date into POSIXlt date/time format
data01 = subset(data, data$Date == "1/2/2007")
data02 = subset(data, data$Date == "2/2/2007")
dataFinal = rbind(data01,data02)
dataFinal$Date <- strptime(paste(dataFinal$Date, dataFinal$Time), "%d/%m/%Y %H:%M:%S")
##Construct 2x2 template for four plots and save to png format
png('plot4.png',bg = "transparent", width = 480, height = 480, units = "px")
par(mfrow = c(2,2))
##Plot1
plot(dataFinal$Global_active_power ~ as.POSIXct(dataFinal$Date), type = "l",ylab = "Global Active Power", xlab = "")
##Plot2
plot(dataFinal$Voltage ~ as.POSIXct(dataFinal$Date), type = "l",ylab = "Voltage", xlab = "datetime")
##Plot3
plot(dataFinal$Sub_metering_1 ~ as.POSIXct(dataFinal$Date), type = "l", ylab = "Energy sub metering", xlab = "")
lines(dataFinal$Sub_metering_2 ~ as.POSIXct(dataFinal$Date), col = "red")
lines(dataFinal$Sub_metering_3 ~ as.POSIXct(dataFinal$Date), col = "blue")
legend("topright", c("Sub_metering_1", "Sub_metering_2", "Sub_metering_3"), col = c("black", "red", "blue"), lty=c(1,1), lwd=c(1,1), bty = "n")
##Plot4
plot(dataFinal$Global_reactive_power ~ as.POSIXct(dataFinal$Date), type = "l",ylab = "Global_reactive_power ", xlab = "datetime")
dev.off()
